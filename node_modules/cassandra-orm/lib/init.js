/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var sprintf = require('sprintf').sprintf;
var async = require('async');
var logmagic = require('logmagic');

var settings = require('./settings');
var migrationRegistry = require('./migrations/registry');
var iterator = require('./orm/iterator');
var constants = require('./orm/constants');
var objectRegistry = require('./orm/object_registry');
var cutils = require('./orm/utils');

/**
 * Options which need to be passed to the initialize function.
 * @type {Array}
 */
var REQUIRED_OPTIONS = ['hosts', 'keyspace', 'modelsPath', 'migrationsPath',
                        'readConsistency', 'writeConsistency'];

var SETTINGS_MAP = {
  'hosts': 'HOSTS',
  'keyspace': 'KEYSPACE',
  'useBigInts': 'USE_BIG_INTS',
  'timeout': 'TIMEOUT',
  'queryTimeout': 'QUERY_TIMEOUT',
  'cqlVersion': 'CQL_VERSION',
  'pooledConnectionCls': 'CONNECTION_CLASS',
  'readConsistency': 'DEFAULT_READ_CONSISTENCY',
  'writeConsistency': 'DEFAULT_WRITE_CONSISTENCY',
  'modelsPath': 'MODELS_PATH',
  'migrationsPath': 'MIGRATIONS_PATH',
  'indexCleanupWhitelist': 'INDEX_CLEANUP_WHITELIST',
  'accountingCf': 'ACCOUNTING_CF',
  'trackedModels': 'TRACKED_MODELS',
  'mergeForUpdateHook': 'MERGE_FOR_UPDATE_HOOK_FUNC',
  'logFunc': 'LOG_FUNC',
  'logRewriterFunc': 'LOG_REWRITER_FUNC',
  'softRemoveTTL': 'SOFT_REMOVE_TTL'
};


/**
 * Initialization function which loads and registers all the
 * available migrations and assigns them to the models.
 *
 * Note: Every failure inside init is fatal which means that this function
 * throws instead of passing error to the callback.
 *
 * @param {Object} options Options with the following keys:
 *
 * - {Array}hosts - Cassandra hosts to connect to.
 * - {String}keyspace - Keyspace to use.
 * - {String}cqlVersion - CQL versionto use (only works with Cassandra 1.1 and
 *                        1.2)
 * - {String}modelsPath - Path to the model files.
 * - {String}migrationsPath - Path to the migration files.
 * - {?Object}pooledConnectionCls - optional Pooled connection class which
 *   should be used instead of the default one
 * - {?Array}indexCleanupWhitelist - models for which to clean the index on
 * - {String}writeConsistency - default write consistency for all the operations.
 * - {String}readConsistency - default read consistency for all the operations.
 * - {?String}accountingCf - name of the column family where the accounting
 *   information is stored.
 * - {?Array}trackedModels - models for which we track the accounting
 *   information.
 * - {?Function}logFunc - handler for the 'log' events emitted by the
 *   PooledConnection.
 * - {?Function}logRewriterFunc - logmagic log rewriter function.
 * - {?Function} softRemoveTTL - TTL after which to permanently remove removed
 *   objects.
 * @param {Function} callback Callback called with ().
 */
exports.initialize = function initialize(options, callback) {
  var migrations, names;

  async.series([
    function verifyRequiredOptionsAreProvided(callback) {
      REQUIRED_OPTIONS.forEach(function(option) {
        if (!options.hasOwnProperty(option)) {
          throw new Error('Missing required option: ' + option);
        }
      });

      callback();
    },

    function assignSettings(callback) {
      var key, settingsKey, value;

      for (key in SETTINGS_MAP) {
        if (SETTINGS_MAP.hasOwnProperty(key)) {
          settingsKey = SETTINGS_MAP[key];
          value = options[key];

          if (options.hasOwnProperty(key)) {
            settings[settingsKey] = value;
          }
        }
      }

      callback();
    },

    // Load and register models
    objectRegistry.discoverModelFiles,

    migrationRegistry.loadAllMigrations,

    // Verify that each model has operationalVersion field and that it is valid
    function verifyModelsOperationalVersionField(callback) {
      migrations = migrationRegistry.getAllMigrations();
      names = Object.keys(migrations);

      async.forEach(names, function(name, callback) {
        var model = objectRegistry[name],
            operationalVersion = model.operationalVersion;

        if (!model.hasOwnProperty('operationalVersion')) {
          callback(new Error(sprintf('Model %s has no "operationalVersion" attribute!', name)));
          return;
        }

        if (!migrations[name].versions.hasOwnProperty(operationalVersion)) {
          callback(new Error(sprintf('Migration with version %s for model %s doesn\'t exist',
                               operationalVersion, name)));
          return;
        }

        callback();
      }, callback);
    },

    function assignMigrationsToModels(callback) {
      async.forEach(names, function(name, callback) {
        var model = objectRegistry[name];
        model._migrations = migrations[name];
        callback();
      }, callback);
    },

    function setUpLogRewriter(callback) {
      if (!settings.LOG_REWRITER_FUNC) {
        callback();
        return;
      }

      logmagic.addRewriter(settings.LOG_REWRITER_FUNC);
      callback();
    }
  ],

  function(err) {
    if (err) {
      throw err;
    }

    callback();
  });
};
