/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var util = require('util');

var sprintf = require('sprintf').sprintf;
var log = require('logmagic').local('lib.orm.utils');
var cass = require('cassandra-client');
var UUID = require('rackspace-shared-utils/lib/uuid').UUID;
var misc = require('rackspace-shared-utils/lib/misc');

var settings = require('../settings');
var errors = require('../errors');
var registry = require('./object_registry');
var getObject = require('./object_registry').getObject;
var constants = require('./constants');
var SCOPED_INDEX_TYPES = require('./constants').SCOPED_INDEX_TYPES;
var INDEX_KEY_DELIM = require('./constants').INDEX_KEY_DELIM;

/**
 * Reference to the cassandra connection pool.
 * @type {Object}
 */
var GLOBAL_CONN_POOL = null;

/**
 * Given a raw node-cassandra-client error, classify it into an error type.
 * @param {Error} err The error to classify.
 * @return {Error} An ele error.
 */
exports.genCassError = function(err) {
  if (err.message.indexOf('ECONNREFUSED') !== -1 || err.message.indexOf('All connections are unhealthy.') === 0) {
    // since this error was generated outside of cassandra, it will not have a details field.
    return new errors.DbDownError(err.message, 'ECONNREFUSED');
  } else if (err.name === 'TimedOutException') {
    return new errors.CassandraTimedOutError(err.message);
  } else if (err.name === 'UnavailableException') {
    return new errors.CassandraUnavailableError(err.message);
  } else {
    return new errors.CassandraError(err.message, err.name);
  }
};

/**
 * Makes sure log message is an object.
 */
exports.rightLogObject = function(message) {
  var i, leni, value;

  if (message instanceof Object) {
    if (message.args && (message.args instanceof Array)) {
      for (i = 0, leni = message.args.length; i < leni; i++) {
        value = message.args[i];
        if ((value instanceof Buffer || value instanceof UUID)) {
          message.args[i] = value.toString();
        }
      }
    }

    return message;
  } else {
    return {message: message};
  }
};

function ConnectionPool(config) {
  cass.PooledConnection.call(this, config);
}

util.inherits(ConnectionPool, cass.PooledConnection);

ConnectionPool.prototype.execute = function(ctx, query, args, callback) {
  cass.PooledConnection.prototype.execute.call(this, query, args, function(err, results) {
    if (err) {
      err = exports.genCassError(err);
    }

    callback(err, results);
  });
};


/**
 * Get a Cassandra connection pool.
 * @param {object} options Options object with the following keys:
 * - {Array} hosts An array of strings, each one a hostname.
 * - {string} keyspace The keyspace to connect to.
 * - {boolean} use_bigints Switches if the cassandra connection uses bigints.
 * - {number} timeout Cassandra connection timeout.
 * - {number} query_timeout Single query execution timeout.
 * @return {cass.PooledConnection} Active pool to use.
 */
exports.getConnPool = function(options) {
  var cls;

  options = options || {};
  options.hosts = options.hosts || settings.HOSTS;
  options.keyspace = options.keyspace || settings.KEYSPACE;
  options.use_bigints = options.use_bigints || settings.USE_BIG_INTS;
  options.timeout = options.timeout || settings.TIMEOUT;
  options.query_timeout = options.query_timeout || settings.QUERY_TIMEOUT;
  options.cql_version = options.cql_version || settings.CQL_VERSION;

  cls = settings.CONNECTION_CLASS || ConnectionPool;

  if (!GLOBAL_CONN_POOL) {
    GLOBAL_CONN_POOL = misc.construct(cls, [options]);

    if (settings.LOG_FUNC) {
      GLOBAL_CONN_POOL.on('log', settings.LOG_FUNC);
    }

    // Warm up the connection.
    GLOBAL_CONN_POOL.connect(function(err) {
      if (err) {
        log.error('Problem connecting', {'err': err});
      }
      else {
        log.info('Connected');
      }
    });
  }

  return GLOBAL_CONN_POOL;
};


/**
 * Concatenate according to our business logic.
 * @param {Array} keyParts parts of the key.
 * @return {String} return the compoundKey.
 */
exports.compoundColumn = function(keyParts) {
  return keyParts.join(constants.DELIM);
};


/**
 * Explode a column into parts
 * @param {String} key take the key.
 * @return {Array} return the parts.
 */
exports.explodeColumn = function(key) {
  return key.split(constants.DELIM);
};


/**
 * Explode index column name into parts.
 * @param {String} name column name.
 * @return {Array} return the parts.
 */
exports.explodeScopedIndexColumn = function(name) {
  var split = name.split(INDEX_KEY_DELIM);

  return exports.explodeColumn(split[1]);
};


/**
 * De-initialize client code.  This function must be called prior to
 * shutdown, to cleanly terminate open database connections.
 *
 * @param {function} callback (without args) once shutdown is complete.
 */
exports.shutdown = function(callback) {
  // if we're not connected, we don't want to shut down.
  if (!GLOBAL_CONN_POOL) {
    callback();
    return;
  }

  exports.getConnPool().shutdown(function(err) {
    GLOBAL_CONN_POOL = null;
    callback(err);
  });
};


/**
 * Basically validate the index, with the parameters passed in.
 * @param {Object} indexObj the definition of the index.
 * @return {Object} the indexDefinition.
 */
exports.addIndex = function(indexObj) {
  if (!indexObj.name) { throw new Error('Necessary for an index to have a name.'); }
  if (!indexObj.columnFamily) { throw new Error('Necessary for an index to have a columnFamily.'); }

  // An index may provide its own _getKeys, otherwise we default to resolving indexObj.key
  if (!indexObj._getKeys) {
    if (!indexObj.key) { throw new Error('Necessary for an index to have a key.'); }
    indexObj._getKeys = function(bi, obj, meta) {
      var res = bi._resolveProperties(indexObj.key, obj, meta);

      if (!res) {
        return [];
      }

      return [bi._resolveProperties(indexObj.key, obj, meta)];
    };
  }

  if (indexObj.name[0] !== '$ROWKEY') {
    throw new Error('$ROWKEY has to be the first parameter of an index name.');
  }

  if (indexObj.name[indexObj.name.length - 1] !== '$OBJKEY') {
    throw new Error('$OBJKEY has to be the last parameter of an index name.');
  }

  if (!indexObj.relationship) {
    throw new Error('Relationship type has to exist!');
  }

  indexObj._rowKeyPosition = 0;
  indexObj._objKeyPosition = indexObj.name.length - 1;
  indexObj.meta = { columnFamily: indexObj.columnFamily };
  return indexObj;
};

/**
 * Responsible for converting a binary column name into a string that can be operated on.
 * @param {DBBase} def object definition.
 * @param {Boolean} explodeCol true to call explodeColumn on the column name if
 * no converter is specified. Defaults to false.
 * @return {Function} that accepts a buffer and converts it to an array of strings.
 */
exports.makeColNameConverter = function(def, explodeCol) {
  explodeCol = explodeCol || false;

  if (def.meta.colNameConverter) {
    return def.meta.colNameConverter;
  }
  else {
    return function(buf) {
      var name = buf.toString('utf8');

      if (explodeCol) {
        name = exports.explodeColumn(name);
      }

      return name;
    };
  }
};

/**
 * Return an ending prefix based on the starting and the object type.
 *
 * Note: This function does not add data prefix to the beginning of the key.
 * @param {db.model} type Requested object type.
 * @param {Boolean} includeChildren true if the children should be included.
 * @param {?String} starting Starting prefix.
 * @param {?Ending} ending Ending prefix.
 * @return {String} Ending prefix.
 */
exports.getEndingPrefix = function(type, includeChildren, starting, ending) {
  var startPrefix, typePrefix, exploded, len, i;

  if (includeChildren && starting && ending && starting === ending) {
    // This is a special case - we are retrieving a single object but we also
    // want to retrieve the children so the end key must be starting+END_TOKEN.
    ending = ending + constants.END_TOKEN;
    return ending;
  }

  if (ending) {
    // ending is provided, nothing to do.
    return ending;
  }

  if (starting) {
    // Starting provided, build ending based on the starting key and type.
    startPrefix = getObject(starting).prefix();
    typePrefix = type.prefix();
    exploded = exports.explodeColumn(starting);
    len = exploded.length;
    i = 0;

    if (len > 1) {
      // Compound key passed in. Key which is passed in could be in the any of
      // the following forms:
      //
      // - enAAAA:chBBBB -> (ending) enAAA:ch+END_TOKEN
      // - enAAA:chBBBB:bcAAA -> (ending) enAAA:chBBBB:bc+END_TOKEN
      // - enAAA:chBBBB:bcAAA:saAAAA -> (ending) enAAA:chBBBB:bcAAA:sa+END_TOKEN
      typePrefix = getObject(exploded[len - 1]).prefix();
      ending = exports.compoundColumn(exploded.slice(0, exploded.length - 1)) +
               constants.DELIM + typePrefix + constants.END_TOKEN;
      return ending;
    }

    if (startPrefix !== typePrefix) {
      // Start and type prefix are not the same - we are retrieving a child
      // objects with a compound key.
      //
      // Example:
      // starting: enAAAA (prefix: en)
      // type: Check (prefix: ch)
      // output (ending): enAAAA:ch+END_TOKEN
      ending = exports.compoundColumn([starting, typePrefix]) + constants.END_TOKEN;
    }
    else {
      // Start and type prefix are the same.
      //
      // Example:
      // starting: enAAAA
      // Type: Entity (prefix: en)
      // output (ending): en+END_TOKEN
      ending = typePrefix + constants.END_TOKEN;
    }
  }
  else {
    ending = constants.END_TOKEN;
  }

  return ending;
};

/**
 * Build a string of ? placeholders which can be used in Cassandra queries.
 *
 * @param {Number} len Number of placeholders to insert.
 * @return {String} Placeholder string.
 */
exports.buildPlaceholderString = function(len) {
  var i, str = '';

  for (i = 0; i < len; i++) {
    str += '?';

    if (i !== (len - 1)) {
      str += ',';
    }
  }

  return str;
};

/**
 * Verify that the provided key starts with the correct object prefix.
 *
 * Note: This function only checks the object keys and ignores the parent key in
 * case an object has parents.
 *
 * @param {Object} Obj the object type.
 * @param {String} key Object primary key.
 * @return {Boolean} true if the key is valid, false otherwise.
 */
exports.isValidKey = function(Obj, key) {
  var exploded, parents, objPrefix = Obj.prefix();

  if (typeof key !== 'string' && !(key instanceof String)) {
    return false;
  }

  if (!objPrefix) {
    // This type doesn't have a prefix.
    return true;
  }

  parents = Obj.parents();

  if (parents) {
    exploded = exports.explodeColumn(key);
    key = exploded[exploded.length - 1];
  }

  if (key.indexOf(objPrefix) === 0) {
    return true;
  }

  return false;
};

/**
 * Construct a full valid key based on the object type, the user
 * provided 'marker' value and the 'starting' prefix.
 *
 * @param {Object} type Object type.
 * @param {String} marker Marker as provided by the user.
 * @param {String} starting Starting key as passed in by the calling function.
 * @return {String} Full key.
 */
exports.getFullKeyFromMarker = function(type, marker, starting) {
  var parentsLen = type.parents().length, exploded, key;

  if (parentsLen === 0) {
    return marker;
  }

  // User always provided last part of the key
  exploded = exports.explodeColumn(starting);
  exploded[exploded.length - 1] = marker;
  key = exports.compoundColumn(exploded);
  return key;
};

/**
 * Return an object key (last part of the key) from the full key.
 *
 * @param {String} key Full key to operate on.
 * @return {String} Object key.
 */
exports.getObjectKey = function(key) {
  var exploded;
  if (!key) {
    return null;
  }

  exploded = exports.explodeColumn(key);
  return exploded[exploded.length - 1];
};

/**
 * return a connection pool suitable for testing.
 * @param {Array} hosts array of host strings in host:port format.
 * @param {String} keyspace name of keyspace to connect to.
 * @return {cass.PooledConnection} a connection pool.
 */
exports.getPoolUnsafe = function(hosts, keyspace) {
  var pool = new ConnectionPool({'hosts': hosts, 'keyspace': keyspace, 'use_bigints': false});
  return pool;
};

/**
 * Return index row key.
 *
 * @param {String} rowKey Object row key.
 * @param {Object} indexObj Index object.
 * @param {String} indexKey Index key.
 * @return {String} Index row key.
 */
exports.getIndexRowKey = function(rowKey, indexObj, indexKey) {
  var indexRowKey;

  if (SCOPED_INDEX_TYPES.indexOf(indexObj.relationship) !== -1) {
    indexRowKey = rowKey;
  }
  else {
    if (indexObj.scopeToObjectRowKey) {
      indexRowKey = exports.compoundColumn([rowKey, indexKey]);
    }
    else {
      indexRowKey = indexKey;
    }
  }

  return indexRowKey;
};
