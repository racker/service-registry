/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var path = require('path');

var async = require('async');
var log = require('logmagic').local('lib.orm.object_registry');

var fsUtil = require('rackspace-shared-utils/lib/fs');

var settings = require('../settings');

var cache = {};
var maxSize = 0;
var minSize = Number.MAX_VALUE;
var dataCache = {};
var dataMaxSize = 0;
var dataMinSize = Number.MAX_VALUE;

function cacheDataPrefix(objectDefinition) {
  var dataPrefix = objectDefinition.dataPrefix();

  if (dataPrefix) {
    dataCache[dataPrefix] = true;
    dataMaxSize = dataPrefix.length > dataMaxSize ? dataPrefix.length : dataMaxSize;
    dataMinSize = dataPrefix.length < dataMinSize ? dataPrefix.length : dataMinSize;
  }
}

function cacheNormalPrefix(objectDefinition) {
  var prefix = objectDefinition.prefix();

  if (prefix) {
    cache[prefix] = objectDefinition;
    maxSize = prefix.length > maxSize ? prefix.length : maxSize;
    minSize = prefix.length < minSize ? prefix.length : minSize;
  }
}

function cacheFullPrefix(objectDefinition) {
  var fullPrefix = objectDefinition.fullPrefix();

  if (fullPrefix) {
    cache[fullPrefix] = objectDefinition;
    maxSize = fullPrefix.length > maxSize ? fullPrefix.length : maxSize;
    minSize = fullPrefix.length < minSize ? fullPrefix.length : minSize;
  }
}

/**
 * Register an objectDefinition
 * @param {Object} objectDefinition the definition of the object.
 */
exports.register = function(objectDefinition) {
  cacheDataPrefix(objectDefinition);
  cacheNormalPrefix(objectDefinition);
  cacheFullPrefix(objectDefinition);

  exports[objectDefinition._name] = objectDefinition;
};

/**
 * Remove the prefix only for the dataprefix.
 * @param {String} key the key to strip the data prefix from.
 * @return {String} the modified string.
 */
exports.removeDataPrefix = function(key) {
  var result,
      i;

  if (key.length < dataMinSize) {
    return key;
  }

  // Can't have a 0 length prefix
  for (i = Math.min(key.length, dataMaxSize); i > 0; i--) {
    result = dataCache[key.substring(0, i)];
    if (result) {
      return key.substring(i);
    }
  }

  // return null if not found
  return key;
};

/**
 * Retrieve an object definition from the registry basedon the object definition
 * and key.
 *
 * @param {Object} objectDefinition Object definition.
 * @param {String} key Object key.
 * @return {ObjectDefinition} return the object definition that has been
 * registered.
 */
exports.getObjectForDefinitionAndKey = function(objectDefinition, key) {
  var Def;

  if (objectDefinition._lookupByName) {
    Def = exports[objectDefinition._name];
  }
  else {
    Def = exports.getObject(key);

    // some datatypes have column names that do not correspond to their types.  If that happens, do a lookup by prefix.
    if (!Def) {
      Def = exports.getObject(objectDefinition.meta.prefix);
    }
  }

  if (!Def) {
    throw new Error('Programmer error, bad data in the database no mapping for key ' + key);
  }

  return Def;
};

/**
 * Get an object definition from the registry
 * @param {String} key the key to use to pull the definition.
 * @return {ObjectDefinition} return the object definition that has been
 *         registered or a null value if not found.
 */
exports.getObject = function(key) {
  var result,
      i;

  if (key.length < minSize) {
    return null;
  }

  // Can't have a 0 length prefix
  for (i = Math.min(key.length, maxSize); i > 0; i--) {
    result = cache[key.substring(0, i)];
    if (result) {
      return result;
    }
  }

  // return null if not found
  return null;
};

/**
 * Return model object for all the objects in the registry.
 *
 * @param {Boolean} lowercase True to lowercase the model name (defaults to
 * false).
 * @return {Array} Array of model objects.
 */
exports.getModelNames = function getModelObjects(lowercase) {
  var models = [];

  Object.keys(exports).forEach(function(key) {
    var value = exports[key],
        name = (lowercase) ? key.toLowerCase() : key;

    if (value.hasOwnProperty('fields')) {
      models.push(name);
    }
  });

  return models;
};

/**
 * This function discovers all the model files and imports them which makes them
 * register with the registry.
 *
 * @param {Function} callback Callback called with (err).
 */
exports.discoverModelFiles = function discoverModelFiles(callback) {
  fsUtil.getMatchingFiles(settings.MODELS_PATH, /\.js$/, null, function(err, files) {
    if (err) {
      callback(err);
      return;
    }

    async.forEach(files, function(file, callback) {
      try {
        require(file);
      }
      catch (err) {
        log.error('Failed to import model file, skipping...', {'file': file, 'err': err.toString()});
      }

      callback();
    }, callback);
  });
};
