/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var path = require('path');
var fs = require('fs');

var term = require('terminal');
var sprintf = require('sprintf').sprintf;
var async = require('async');
var logmagic = require('logmagic');
var log = logmagic.local('migrations');

var settings = require('../settings');
var objectRegistry = require('../orm/object_registry');
var migrations = require('./migrations');
var migrationConstants = require('./constants');
var migrationsRegistry = require('./registry');
var migrationUtils = require('./utils');
var utils = require('../utils');

logmagic.registerSink('client_migrations', utils.buildSink(false));
logmagic.route('migrations.*', logmagic.INFO, 'client_migrations');

/**
 * Return an array of model names.
 * Note: Object registry must be populated before calling this method.
 *
 * @param {String} name Model name or 'all' to retrieve all the model names.
 * @return {Array} Array of model names.
 */
function getModelNames(name) {
  var result;

  if (name === 'all') {
    result = objectRegistry.getModelNames();
  }
  else {
    result = [name];
  }

  return result;
}

/**
 * Verify that the provided name is a valid model name or 'all'.
 * Note: Object registry must be populated before calling this method.
 *
 * @param {String} name Model name.
 * @param {Function} callback Callback called with (err).
 */
function verifyModelName(name, callback) {
  var names = objectRegistry.getModelNames(),
      err = null;

  if (name !== 'all' && names.indexOf(name) === -1) {
    err = new Error(sprintf('Invalid model name: [bold]%s[/bold].\nValid names are: %s',
                            name, ['all'].concat(names).join(', ')));
  }

  callback(err);
}

/**
 * Find the differences between last model version available in the migration
 * registry and the current one.
 *
 * @param {String} modelName Model name to inspect or 'all' for all.
 * @param {Function} callback Callback called with (err,
 * numberOfFilesWithChanges).
 */
exports.inspect = function inspect(modelName, callback) {
  var models, modelMigrations, lastMigration, currentModelFields, diff,
      filesWithChanges = 0;

  function inspectModel(name, callback)  {
    modelMigrations = migrationsRegistry.getMigrations(name);

    if (!modelMigrations) {
      log.errorf('Could not find migrations files for model ${m}. Are you sure you have ran init?',
                 {'m': name});
      callback(true);
      return;
    }

    lastMigration = modelMigrations.versions[modelMigrations.lastVersion];

    try {
      currentModelFields = objectRegistry[name].fields;
    }
    catch (err) {
      log.errorf('Failed to load current model file: ${e}', {'e': err.toString()});
      process.exit(1);
    }

    diff = migrations.getModelsFieldsDiff(lastMigration.FIELDS, currentModelFields);

    term.puts(sprintf('Differences for model [bold]%s[/bold] between version [bold]%s[/bold] and ' +
                      '[bold]current[/bold]\n',
                      name, modelMigrations.lastVersion));

    if (!migrationUtils.hasDifferences(diff)) {
      term.puts('None.');
      callback();
      return;
    }
    else {
      filesWithChanges++;
    }

    term.puts('Added fields:');

    diff.add.forEach(function(field) {
      term.puts(' ' + field.toString());
    });

    term.puts('\nRemoved fields:');

    diff.remove.forEach(function(field) {
      term.puts(' ' + field.toString());
    });

    term.puts('\nChanged field options:');

    diff.change_options.forEach(function(field) {
      term.puts(' ' + field.toString());
    });

    callback();
  }


  async.series([
    objectRegistry.discoverModelFiles,
    migrationsRegistry.loadAllMigrations,

    verifyModelName.bind(null, modelName),

    function inspectModels(callback) {
      var toInspect = getModelNames(modelName);
      async.forEach(toInspect, inspectModel, callback);
    }
  ],

  function(err) {
    if (err) {
      term.puts(err.toString());
    }
    callback(err, filesWithChanges);
  });
};

/**
 * Create initial directory structure for the migration files and create an
 * initial migration file where the version is 0.
 *
 * @param {String} modelName Model name to inspect or 'all' for all.
 * @param {Function} callback Callback called with (err).
 */
exports.initialize = function initialize(modelName, callback) {
  var modelNames, migrationFiles;

  function createInitialMigrationFile(name, callback) {
    async.waterfall([
      function checkIsValidModel(callback) {
        if (modelNames.indexOf(name) === -1) {
          log.errorf('Invalid model name ${m}, skipping...', {'m': name});
          callback(true);
          return;
        }

        callback();
      },

      function createMigrationsDirectory(callback) {
        var migrationFolderName = name.toLowerCase(),
            directory = path.join(settings.MIGRATIONS_PATH, migrationFolderName);

        if (!path.existsSync(directory)) {
          log.infof('Creating migrations directory: [bold]${d}[/bold]', {'d': directory});

          fs.mkdir(directory, parseInt(755, 8), function(err) {
            if (err) {
              log.infof('Failed to create migration directory "${d}", skipping...', {'d': directory});
            }

            callback();
          });

          return;
        }

        callback();
      },

      function createInitialMigration(callback) {
        var file = path.join(settings.MIGRATIONS_PATH, name.toLowerCase(),
            migrationConstants.INITIAL_MIGRATION_FILENAME),
            modelMigrationFiles = migrationFiles[name];

        if (!migrationFiles.hasOwnProperty(name) || modelMigrationFiles.indexOf(file) === -1) {
          log.infof('Creating initial migration file: [bold]${f}[/bold]', {'f': file});
          // TODO: Put in a separate function
          async.waterfall([
            function getStub(callback) {
              migrations.getMigrationFileStub(objectRegistry[name], 0, callback);
            },

            function writeMigrationFile(stub, callback) {
              fs.writeFile(file, stub, 'utf8', callback);
            }
          ], callback);
          return;
        }

        callback();
      }
    ],

    function(err) {
      callback();
    });
  }

  async.waterfall([
    objectRegistry.discoverModelFiles,
    migrationsRegistry.discoverMigrationFiles,

    function createInitialMigrationFiles(_migrationFiles, callback) {
      var toCreate = getModelNames(modelName);
      modelNames = objectRegistry.getModelNames();
      migrationFiles = _migrationFiles;

      async.forEachSeries(toCreate, createInitialMigrationFile, callback);
    }
  ],

  function(err) {
    callback(err);
  });
};

/**
 * Generate and write out a migration file.
 *
 * @param {String} modelName Model name or 'all'.
 * @param {String} migrationName Name of the migration.
 * @param {Object} options Options object.
 * @param {Function} callback Callback called with (err).
 *
 */
exports.generate = function generate(modelName, migrationName, options, callback) {
  options = options || {};
  var includeModelsWithoutChanges = options.includeModelsWithoutChanges || false;

  function createMigrationFile(modelName, callback) {
    var lastVersion, currentVersion, version, fileName, filePath;

    async.waterfall([
      function checkMigrationsDirectoryExist(callback) {
        var modelMigrations = migrationsRegistry.getMigrations(modelName);

        if (!modelMigrations) {
          log.errorf('Could not find migrations files for model ${m}. Skipping...',
                     {'m': modelName});
          callback(true);
          return;
        }

        callback(null, modelMigrations);
      },

      function checkForDifferences(modelMigrations, callback) {
        var lastVersion, currentVersion, version, diff;

        lastVersion = modelMigrations.versions[modelMigrations.lastVersion];
        currentVersion = objectRegistry[modelName];
        version = ++modelMigrations.lastVersion;
        diff = migrations.getModelsFieldsDiff(lastVersion.FIELDS, currentVersion.fields);

        if (!migrationUtils.hasDifferences(diff) && !includeModelsWithoutChanges) {
          log.errorf('No differences found between last available (${lv}) and current version' +
                     ' for model [bold]${m}[/bold]. To generate migration file for model' +
                     ' without changes, use the -y option',
                     {'lv': modelMigrations.lastVersion, 'm': modelName});
          callback(true);
          return;
        }

        callback(null, modelMigrations, version);
      },

      function getStub(modelMigrations, version, callback) {
        migrations.getMigrationFileStub(objectRegistry[modelName], version, function(err, stub) {
          callback(err, stub, version);
        });
      },

      function writeMigrationFile(stub, version, callback) {
        var fileName = migrationUtils.getMigrationFileName(version, migrationName),
            filePath = path.join(settings.MIGRATIONS_PATH, modelName.toLowerCase(), fileName);

        log.infof('Creating migration file: [bold]${f}[/bold]', {'f': filePath});
        fs.writeFile(filePath, stub, 'utf8', callback);
      }
    ],

    function(err) {
      callback();
    });
  }

  async.waterfall([
    objectRegistry.discoverModelFiles,
    migrationsRegistry.loadAllMigrations.bind(migrations),

    function createMigrationFiles(callback) {
      var toCreate = getModelNames(modelName);
      async.forEachSeries(toCreate, createMigrationFile, callback);
    }
  ], callback);
};
