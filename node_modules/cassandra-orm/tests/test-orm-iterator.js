/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var async = require('async');
var logmagic = require('logmagic');
var log = require('logmagic').local('tests.test-orm-iterator');
var randstr = require('rackspace-shared-utils/lib/misc').randstr;

var RowPaginatedIndexIterator = require('../lib/orm/iterator').RowPaginatedIndexIterator;
var ColumnIterator = require('../lib/orm/iterator').ColumnIterator;
var BaseObjectIterator = require('../lib/orm/iterator').BaseObjectIterator;
var BaseIterator = require('../lib/orm/iterator').BaseIterator;
var ObjectIterator = require('../lib/orm/iterator').ObjectIterator;
var PaginatedObjectIterator = require('../lib/orm/iterator').PaginatedObjectIterator;
var FilteredObjectIterator = require('../lib/orm/iterator').FilteredObjectIterator;
var IndexIterator = require('../lib/orm/iterator').IndexIterator;
var PaginatedIndexIterator = require('../lib/orm/iterator').PaginatedIndexIterator;
var RowKeyIterator = require('../lib/orm/iterator').RowKeyIterator;
var BatchInsert = require('../lib/orm/batch_insert').BatchInsert;

var Entity = require('../examples/models/entity').Entity;
var Account = require('../examples/models/account').Account;
var Check = require('../examples/models//check').Check;
var BoundCheck = require('../examples/models/bound_check').BoundCheck;
var AgentToken = require('../examples/models/agent_token').AgentToken;
var Service = require('../examples/models/service').Service;

var Person = require('../examples/models/person').Person;

var makeColNameConverter = require('../lib/orm/utils').makeColNameConverter;
var cutils = require('../lib/orm/utils');
var REMOVED_FIELD = require('../lib/orm/constants').SPECIAL_FIELDS.removed;
var errors = require('../lib/errors');


var common = require('./common');

var context = {};
context.create = function(log) { return {'log': log}; };

exports['setUp'] = common.setUp;
exports['tearDown'] = common.tearDown;

function removeKey(ctx, key, callback) {
  var bi = new BatchInsert(ctx, key);
  bi.begin();
  bi.removeKey(Entity);
  bi.commit(callback);
}

function removeKeyDef(ctx, key, def, callback) {
  var bi = new BatchInsert(ctx, key);
  bi.begin();
  bi.removeKey(def);
  bi.commit(callback);
}

function attachError(emitter, assert) {
  emitter.on('error', function(err) {
    assert.deepEqual(null, err);
  });
}

exports['test_object_iterator__expandColumns'] = function(test, assert) {
  var ctx = context.create(log),
      oi = new BaseObjectIterator(ctx, Entity, null),
      res;

  res = oi._expandColumns(['enA'], false);
  assert.deepEqual(res, ['_enA']);
  res = oi._expandColumns(['enA:chB:bcA'], false);
  assert.deepEqual(res, ['_enA', 'enA:chB', 'enA:chB:bcA']);
  res = oi._expandColumns(['enA:chB:bcA', 'enB:chFU:bcOMG'], false);
  assert.deepEqual(res, ['_enA', 'enA:chB', 'enA:chB:bcA', '_enB',
                         'enB:chFU', 'enB:chFU:bcOMG']);
  test.finish();
};

exports['test_base_iterator_end_and_error_is_only_emitted_once'] = function(test, assert) {
  var ctx = context.create(log),
      iter1 = new BaseIterator(ctx),
      iter2 = new BaseIterator(ctx),
      iter3 = new BaseIterator(ctx),
      iter4 = new BaseIterator(ctx),
      endEmittedCount = 0, errorEmittedCount = 0,
      err = new Error('ponnies!');

  // set up handlers
  [iter1, iter2, iter3, iter4].forEach(function(iter) {
    iter.on('error', function() {
      errorEmittedCount++;
    });

    iter.on('end', function() {
      endEmittedCount++;
    });
  });

  assert.equal(errorEmittedCount, 0);
  assert.equal(endEmittedCount, 0);

  // emit error twice
  iter1._emitError(err);
  iter1._emitError(err);

  assert.equal(errorEmittedCount, 1);
  assert.equal(endEmittedCount, 0);

  // emit end twice
  iter2._emitEnd();
  iter2._emitEnd();

  assert.equal(errorEmittedCount, 1);
  assert.equal(endEmittedCount, 1);

  // emit error and than end
  iter3._emitError(err);
  iter3._emitEnd();

  assert.equal(errorEmittedCount, 2);
  assert.equal(endEmittedCount, 1);

  // emit end and than error
  iter4._emitEnd();
  iter4._emitError(err);

  assert.equal(errorEmittedCount, 2);
  assert.equal(endEmittedCount, 2);

  test.finish();
};

exports['test_index_map'] = function(test, assert) {
  var ctx = context.create(log),
      acct = new Account({'external_id': 'ponies'}),
      bi = new BatchInsert(ctx, acct.getKey()),
      map;

  map = acct.getIndexMap(bi);
  assert.deepEqual(map['external_idx'], ['ponies']);
  test.finish();
};

exports['test_base_iterator_expand_columns_remove_ordered_dups'] = function(test, assert) {
  var ctx = context.create(log),
      iter1 = new BaseObjectIterator(ctx, BoundCheck),
      wackyList = ['enA', 'enA:chA:bcA', 'enA:chA:bcB', 'enA:chB', 'enA', 'enB', 'enB:chC:bc', 'enA:chD:bc'],
      saneList = ['enA', 'enA:chA:bcA', 'enA:chA:bcB', 'enB', 'enB:chB:bcC'],
      results;

  results = iter1._expandColumns(wackyList);
  assert.deepEqual(results, [
    '_enA',
    'enA:chA',
    'enA:chA:bcA',
    'enA:chA:bcB',
    'enA:chB',
    '_enB',
    'enB:chC',
    'enB:chC:bc',
    '_enA',
    'enA:chD',
    'enA:chD:bc'
  ]);

  results = iter1._expandColumns(saneList);
  assert.deepEqual(results, ['_enA', 'enA:chA', 'enA:chA:bcA', 'enA:chA:bcB', '_enB', 'enB:chB', 'enB:chB:bcC']);

  test.finish();
};

exports['test_col_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      ri = new ColumnIterator(ctx, Entity.meta.columnFamily, {'batchSize': 1000, 'dataPrefix': Entity.meta.dataPrefix}),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      objs = 321, i,
      testCount = 0,
      testRowCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    ri.getSlice([acctId], {colNameConverter: makeColNameConverter(Entity, true)});
    attachError(ri, assert);
    ri.on('row', function(row) {
      testRowCount++;
    });
    ri.on('column', function(nameValueTuple) {
      testCount++;
    });
    ri.on('end', function() {
      assert.equal(1, testRowCount);
      assert.equal(ri.total, testCount);
      assert.equal(ri.total, objs);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_col_iterator_one_col'] = function(test, assert) {
  var ctx = context.create(log),
      ri = new ColumnIterator(ctx, Entity.meta.columnFamily, {'dataPrefix': Entity.meta.dataPrefix}),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      eId, i,
      objs = 21,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    if (!eId) {
      eId = en.getKey();
    }
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    async.waterfall([
      function getOneCol(callback) {
        ri.getOneColumn(acctId, eId, callback); // err, result
      },
      function getSliceOneRow(oneCallResult, callback) {
        var resultCount = 0;
        ri.getSlice([acctId], {starting: eId, ending: eId, colNameConverter: makeColNameConverter(Entity, true)});
        ri.on('column', function(sliceCallResult) {
          resultCount += 1;
          assert.deepEqual(sliceCallResult, oneCallResult);
        });
        ri.on('end', function() {
          assert.strictEqual(resultCount, 1);
          callback();
        });
      }
    ], function(err) {
      assert.ifError(err);
      test.finish();
    });
  });
};

exports['test_PaginatedObjectIterator_getSliceByKey'] = function(test, assert) {
  var ctx = context.create(log),
      acctId = 'aBar1',
      toInsertEntities = 105,
      toInsertChecks = 105,
      toDeleteEntities = 10,
      insertedEntities = [],
      insertedChecks = [],
      insertedBcs = [],
      enKey1;

  async.waterfall([
    function insertEntities(callback) {
      var i, bi, en;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();

      for (i = 0; i < toInsertEntities; i++) {
        en = new Entity({'account_id': acctId, 'label': i});
        insertedEntities.push(en.getKey());
        bi.save(en);
      }

      bi.commit(callback);
    },

    function insertChecks(callback) {
      var i, j, bi, ch, bc, enKey = insertedEntities[insertedEntities.length - 1];
      enKey1 = enKey;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();

      for (i = 0; i < toInsertChecks; i++) {
        ch = new Check({'account_id': acctId, 'label': i, 'entity_id': enKey});

        insertedBcs[i] = [];
        for (j = 0; j < 20; j++) {
          bc = new BoundCheck({'entity_id': enKey, 'check_id': ch.getKey()});
          insertedBcs[i].push(bc.getKey());
          bi.save(bc);
        }

        insertedChecks.push(ch.getKey());
        bi.save(ch);
      }

      bi.commit(callback);
    },

    function retrieveAllEntities(callback) {
      var limit = 200,
          retrieved = 0,
          iter,
          starting = Entity.prefix();

      iter = new PaginatedObjectIterator(ctx, Entity, {'limit': limit});
      iter.getSliceByKey(acctId, false);

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        assert.equal(retrieved, toInsertEntities);
        assert.ok(!data.nextKey);
        callback();
      });
    },

    function retrieveMoreThanAvailableEntities(callback) {
      var limit = 10000,
          iter = new PaginatedObjectIterator(ctx, Entity, {'limit': limit}),
          retrieved = 0;

      iter.getSliceByKey(acctId, true);

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        assert.equal(retrieved, toInsertEntities);
        assert.ok(!data.nextKey);
        callback();
      });
    },

    function retrieveFirst20Entities(callback) {
      var limit = 20,
          iter = new PaginatedObjectIterator(ctx, Entity, {'limit': limit}),
          retrieved = 0,
          queries = 0,
          done = false;

      logmagic.registerSink('cql_sink', function(module, level, message, obj) {
        if (!done) {
          assert.ok(obj.parameterized_query.indexOf('SELECT FIRST 22') >= 0);
          queries++;
        }
      });
      logmagic.route('ele.cassandra-cql', logmagic.TRACE1, 'cql_sink');

      iter.getSliceByKey(acctId, false, 'en');

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        done = true;
        assert.equal(queries, 1);
        assert.equal(retrieved, limit);
        assert.ok(data.nextKey);
        callback();
      });
    },

    function retrieveInvalidKeyEntity(callback) {
      var limit = 200,
          iter = new PaginatedObjectIterator(ctx, Entity, {'limit': limit}),
          retrieved = 0;

      iter.getSliceByKey('invalidkey', false);

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        assert.equal(retrieved, 0);
        assert.ok(!data.nextKey);
        callback();
      });
    },

    function testMarkerSimpleKeyEntities(callback) {
      var limit = 20,
          totalRetrieved = 0,
          iteration = 0,
          marker = null, ending = null,
          allObjects = [];

      async.whilst(function truthTest(callback) {
        iteration++;
        return (iteration === 1 || marker);
      },

      function retrieveWithMarket(callback) {
        var retrieved = 0, objects = [], iter;

        iter = new PaginatedObjectIterator(ctx, Entity, {'limit': limit});
        iter.getSliceByKey(acctId, false, marker, ending);

        iter.on('object', function(obj) {
          objects.push(obj);
          allObjects.push(obj);
          retrieved++;
          totalRetrieved++;
        });

        iter.on('end', function(data) {
          if (objects.length > 0) {
            if (iteration < 6) {
              assert.equal(retrieved, limit);
              assert.ok(data.nextKey);
            }
            else {
              assert.equal(retrieved, 5);
              assert.ok(!data.nextKey);
            }
          }

          marker = data.nextKey || null;
          callback();
        });
      },

      function(end) {
        var i, insertedKey, retrievedKey;

        // Sort the inserted object keys
        insertedEntities.sort();

        for (i = 0; i < allObjects.length; i++) {
          insertedKey = insertedEntities[i];
          retrievedKey = allObjects[i].getKey();
          assert.equal(insertedKey, retrievedKey);
        }

        assert.equal(totalRetrieved, toInsertEntities);
        assert.equal(iteration, (Math.ceil(toInsertEntities / limit) + 1));
        callback(null, allObjects);
      });
    },

    function deleteEntities(allObjects, callback) {
      // Delete first 10 entities
      var i, en, bi, index, removed = [];

      bi = new BatchInsert(ctx, acctId);
      bi.begin();

      for (i = 0; i < toDeleteEntities; i++) {
        en = allObjects[i];
        bi.removeObject(en);

        removed.push(en.getKey());
        index = insertedEntities.indexOf(en.getKey());
        insertedEntities.splice(index, 1);
      }

      bi.commit(function(err) {
        callback(err, removed);
      });
    },

    function testMarkerEntitiesWithDeletedObjects(removed, callback) {
      var limit = 20,
          totalRetrieved = 0,
          retrieved = 0,
          iteration = 0,
          marker = Entity.prefix(),
          ending = null,
          allObjects = [];

      async.whilst(function truthTest(callback) {
        iteration++;
        return totalRetrieved < (toInsertEntities - toDeleteEntities);
      },

      function retrieveWithMarker(callback) {
        var retrieved = 0, objects = [], iter;

        iter = new PaginatedObjectIterator(ctx, Entity, {'limit': 20});
        iter.getSliceByKey(acctId, false, marker, ending);

        iter.on('object', function(obj) {
          objects.push(obj);
          allObjects.push(obj);
          retrieved++;
          totalRetrieved++;
        });

        iter.on('end', function(data) {
          if (objects.length > 0) {
            if (iteration < 5) {
              assert.equal(retrieved, limit);
              assert.ok(data.nextKey);
            }
            else {
              assert.equal(retrieved, 15);
              assert.ok(!data.nextKey);
            }

            marker = data.nextKey;
          }
          else {
            marker = null;
          }

          callback();
        });
      },

      function(end) {
        var i, insertedKey, removedKey, retrievedKey, obj;

        // Sort the inserted object keys
        insertedEntities.sort();

        for (i = 0; i < allObjects.length; i++) {
          obj = allObjects[i];
          insertedKey = insertedEntities[i];

          retrievedKey = allObjects[i].getKey();
          assert.equal(insertedKey, retrievedKey);
          assert.ok((obj[REMOVED_FIELD] === undefined || obj[REMOVED_FIELD] === false));
        }

        assert.equal(totalRetrieved, (toInsertEntities - toDeleteEntities));
        assert.equal(iteration, (Math.ceil((toInsertEntities - toDeleteEntities) / limit) + 1));
        callback();
      });
    },

    function testLessThanAvailableCheck(callback) {
      var limit = 20,
          retrieved = 0,
          starting = cutils.compoundColumn([enKey1, Check.prefix()]),
          queries = 0,
          done = false,
          iter;

      logmagic.registerSink('cql_sink', function(module, level, message, obj) {
        if (!done) {
          // Math.min(20 * (5 + 1), 1000) + 1
          assert.ok(obj.parameterized_query.indexOf('SELECT FIRST 122') >= 0);
          queries++;
        }
      });
      logmagic.route('ele.cassandra-cql', logmagic.TRACE1, 'cql_sink');

      iter = new PaginatedObjectIterator(ctx, Check, {'limit': limit});
      iter.getSliceByKey(acctId, true, starting);

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        done = true;
        // Note: this actually takes extra queries because we inserted 20
        // BoundChecks per Check. So we must iterate 20 * (20 + 1) items in
        // batches of 120.
        assert.equal(queries, Math.ceil(((limit * 21) / 120)));
        assert.equal(retrieved, limit);
        callback();
      });
    },

    function testMoreThanAvailableCheck(callback) {
      var limit = 10000,
          retrieved = 0,
          starting = cutils.compoundColumn([enKey1, Check.prefix()]),
          iter;

      iter = new PaginatedObjectIterator(ctx, Check, {'limit': limit, 'batchSize': 2000});
      iter.getSliceByKey(acctId, true, starting);

      iter.on('object', function(obj) {
        retrieved++;
      });

      iter.on('end', function(data) {
        assert.equal(retrieved, toInsertEntities);
        assert.ok(!data.nextKey);
        callback();
      });
    },

    function testMarkerCompoundKeyCheck(callback) {
      var limit = 20,
          totalRetrieved = 0,
          iteration = 0,
          ending = null,
          allObjects = [],
          starting,
          marker = cutils.compoundColumn([enKey1, Check.prefix()]);

      starting = marker;
      async.whilst(function truthTest(callback) {
        iteration++;
        return (iteration === 1 || marker);
      },

      function retrieveWithMarker(callback) {
        var retrieved = 0, objects = [], iter;

        insertedChecks.sort();

        iter = new PaginatedObjectIterator(ctx, Check, {'limit': limit});
        iter.getSliceByKey(acctId, true, marker, ending);

        iter.on('object', function(obj) {
          objects.push(obj);
          allObjects.push(obj);
          retrieved++;
          totalRetrieved++;
        });

        iter.on('end', function(data) {
          if (objects.length > 0) {
            if (iteration < 6) {
              assert.equal(retrieved, limit);
            }
            else {
              assert.equal(retrieved, 5);
            }
          }

          if (data.nextKey) {
            marker = cutils.getFullKeyFromMarker(Check, data.nextKey, starting);
          } else {
            marker = null;
          }
          callback();
        });
      },

      function(end) {
        var i, insertedKey, retrievedKey;

        // Sort the inserted object keys
        insertedChecks.sort();

        for (i = 0; i < allObjects.length; i++) {
          insertedKey = insertedChecks[i];
          retrievedKey = allObjects[i].getKey();
          assert.equal(insertedKey, retrievedKey);
        }

        assert.equal(totalRetrieved, toInsertChecks);
        assert.equal(iteration, (Math.ceil(toInsertChecks / limit) + 1));
        callback();
      });
    },

    function testMarkerCompoundKeyCheckSmallBatchSize(callback) {
      var limit = 20,
          totalRetrieved = 0,
          iteration = 0,
          ending = null,
          allObjects = [],
          starting,
          marker  = cutils.compoundColumn([enKey1, Check.prefix()]);

      starting = marker;
      async.whilst(function truthTest(callback) {
        iteration++;
        return (iteration === 1 || marker);
      },

      function retrieveWithMarker(callback) {
        var retrieved = 0, objects = [], iter;

        insertedChecks.sort();

        iter = new PaginatedObjectIterator(ctx, Check, {'limit': limit, 'batchSize': 500});
        iter.getSliceByKey(acctId, true, marker, ending);

        iter.on('object', function(obj) {
          objects.push(obj);
          allObjects.push(obj);
          retrieved++;
          totalRetrieved++;
        });

        iter.on('end', function(data) {
          if (objects.length > 0) {
            if (iteration < 6) {
              assert.equal(retrieved, limit);
            }
            else {
              assert.equal(retrieved, 5);
            }
          }

          if (data.nextKey) {
            marker = cutils.getFullKeyFromMarker(Check, data.nextKey, starting);
          } else {
            marker = null;
          }
          callback();
        });
      },

      function(end) {
        var i, insertedKey, retrievedKey;

        // Sort the inserted object keys
        insertedChecks.sort();

        for (i = 0; i < allObjects.length; i++) {
          insertedKey = insertedChecks[i];
          retrievedKey = allObjects[i].getKey();
          assert.equal(insertedKey, retrievedKey);
        }

        assert.equal(totalRetrieved, toInsertChecks);
        assert.equal(iteration, (Math.ceil(toInsertChecks / limit) + 1));
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_PaginatedObjectIterator_getSliceByKey_no_objects_1'] = function(test, assert) {
  var acctId = 'aBar1', retrieved = 0,
      iter,
      ctx = context.create(log),
      starting = cutils.compoundColumn(['enBlahDoesNotExist', Check.prefix()]);

  iter = new PaginatedObjectIterator(ctx, Check, {'limit': 100});
  iter.getSliceByKey(acctId, true, starting, null);

  iter.on('object', function(obj) {
    retrieved++;
  });

  iter.on('end', function(data) {
    assert.equal(retrieved, 0);
    test.finish();
  });
};

exports['test_PaginatedObjectIterator_getSliceByKey_no_objects_2'] = function(test, assert) {
  var acctId = 'aBar1', retrieved = 0,
      iter,
      ctx = context.create(log),
      starting = cutils.compoundColumn(['enBlahDoesNotExist', Check.prefix()]);

  iter = new PaginatedObjectIterator(ctx, Check, {'limit': 100});
  iter.getSliceByKey(acctId, true, starting, null);

  iter.on('object', function(obj) {
    retrieved++;
  });

  iter.on('end', function(data) {
    assert.equal(retrieved, 0);
    test.finish();
  });
};

exports['test_PaginatedObjectIterator_getSliceByKey_no_objects_3'] = function(test, assert) {
  var acctId = 'acctDoesNotExist', retrieved = 0,
      iter,
      ctx = context.create(log),
      starting = cutils.compoundColumn(['enBlahDoesNotExist', Check.prefix()]);

  iter = new PaginatedObjectIterator(ctx, Check, {'limit': 100});
  iter.getSliceByKey(acctId, true, null, null);

  iter.on('object', function(obj) {
    retrieved++;
  });

  iter.on('end', function(data) {
    assert.equal(retrieved, 0);
    test.finish();
  });
};


exports['test_col_iterator_one_col_inexistent_key'] = function(test, assert) {
  var ctx = context.create(log),
      ri = new ColumnIterator(ctx, Entity.meta.columnFamily, {'dataPrefix': Entity.meta.dataPrefix});

  ri.getOneColumn('aainexistent', 'eebzjklmo', function(err, results) {
    assert.ifError(err);
    assert.equal(results, null);
    test.finish();
  });
};

exports['test_obj_iterator_named_cols'] = function(test, assert) {
  var ctx = context.create(log),
      oi = new BaseObjectIterator(ctx, Entity, { count: 10 }),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      eIds = [],
      objs = 21,
      i,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    eIds.push(en.getKey());
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    oi.getColumnListByKey(acctId, eIds);

    oi.on('object', function(obj) {
      testCount++;
    });

    attachError(oi, assert);
    oi.on('end', function() {
      assert.equal(oi.total, testCount);
      assert.equal(oi.total, objs);

      test.finish();
    });
  });
};

exports['test_col_iterator_number_of_results_is_the_same_as_colarray_length'] = function(test, assert) {
  var ctx = context.create(log),
      batchSize = 100,
      ri = new ColumnIterator(ctx, Entity.meta.columnFamily, { batchSize: batchSize, dataPrefix: Entity.meta.dataPrefix }),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      eId = [], i,
      objs = batchSize,
      testCount = 0,
      testPrefix;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    // TODO: this is a hack because we are using the columnIterator interface
    // which doesn't transparently handle prefixing and deprefixing.
    testPrefix = en._type.meta.dataPrefix;
    eId.push(testPrefix + en.getKey());
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    ri.getColumnListByKey(acctId, eId);

    ri.on('column', function(col) {
      testCount++;
    });
    attachError(ri, assert);
    ri.on('end', function() {
      assert.equal(ri.total, testCount);
      assert.equal(ri.total, objs);

      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_col_iterator_named_cols'] = function(test, assert) {
  var ctx = context.create(log),
      ri = new ColumnIterator(ctx, Entity.meta.columnFamily, { count: 10, dataPrefix: Entity.meta.dataPrefix }),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      eId = [], i,
      objs = 21,
      testCount = 0,
      testPrefix;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    // TODO: this is a hack because we are using the columnIterator interface
    // which doesn't transparently handle prefixing and deprefixing.
    testPrefix = en._type.meta.dataPrefix;
    eId.push(testPrefix + en.getKey());
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    ri.getColumnListByKey(acctId, eId);

    ri.on('column', function(col) {
      testCount++;
    });
    attachError(ri, assert);
    ri.on('end', function() {
      assert.equal(ri.total, testCount);
      assert.equal(ri.total, objs);

      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


function getIteratorFilterTestForIterType(getIterator) {
  function innerTest(getIterator, test, assert) {
    function filterFunc(obj) {
      return obj.label < 10;
    }

    var ctx = context.create(log),
        acctId = 'aFoo',
        bi = new BatchInsert(ctx, acctId),
        en, results = [],
        objs = 30, i,
        iter = getIterator(ctx, filterFunc),
        testCount = 0;

    bi.begin();

    for (i = 0; i < objs; i++) {
      en = new Entity({'account_id': acctId, 'label': i});
      bi.save(en);
    }

    bi.commit(function(err) {
      assert.deepEqual(err, null);

      iter.getSliceByKey(acctId, true);
      attachError(iter, assert);
      iter.on('object', function() {
        testCount++;
      });
      iter.on('end', function() {
        assert.equal(iter.total, 10);
        assert.equal(testCount, 10);
        removeKey(ctx, acctId, function(err) {
          assert.ifError(err);
          test.finish();
        });
      });
    });
  }

  return innerTest.bind(null, getIterator);
}


exports['test_obj_iterator_filters'] = getIteratorFilterTestForIterType(
    function getIterator(ctx, filterFunc) {
      return new ObjectIterator(ctx, Entity, {'filters': {'label_gt_ten': filterFunc}});
    });
exports['test_filtered_obj_iterator'] = getIteratorFilterTestForIterType(
    function getIterator(ctx, filterFunc) {
      return new FilteredObjectIterator(ctx, Entity, null, [filterFunc]);
    });


exports['test_obj_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Entity),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      objs = 21, i,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKey(acctId, true);
    attachError(iter, assert);
    iter.on('object', function() {
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_obj_iterator_getSlice'] = function(test, assert) {
  var ctx = context.create(log),
      objs = 40, i = 0, ac,
      inserted = 0, testCount = 0;

  async.series([
    function addEntries(callback) {
      async.whilst(
          function truthTest() {
            inserted++;
            return inserted < (objs - 1);
          },

          function add(callback) {
            var bi, ac;
            i++;
            ac = new Account({'external_id': randstr()});
            bi = new BatchInsert(ctx, ac.getKey());
            bi.begin();
            bi.save(ac);
            bi.commit(callback);
          }, callback);
    },

    function retrieve(callback) {
      var iter = new ObjectIterator(ctx, Account, { limit: 5000 });
      iter.getSlice(false);
      attachError(iter, assert);

      iter.on('object', function(obj) {
        assert.ok(obj instanceof Account);
        testCount++;
      });

      iter.on('end', function() {
        assert.equal(iter.total, i);
        assert.equal(iter.total, testCount);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};


exports['test_hierarchical_obj_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Check),
      acctId = 'aFoo',
      eId = 'en171',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      objs = 16, i,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Check({'account_id': acctId, 'entity_id': eId, 'label': i});
    bi.save(en);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKey(acctId, true);
    attachError(iter, assert);
    iter.on('object', function(obj) {
      assert.equal(obj.entity_id, eId);
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_hierarchical_obj_iterator_changing_eids'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Check),
      acctId = 'aFoo',
      eId = 'en171',
      bi = new BatchInsert(ctx, acctId),
      en, results = [],
      objs = 16, i,
      eIds = {},
      ch,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'label': i});
    bi.save(en);
    ch = new Check({'account_id': acctId, 'entity_id': en.getKey(), 'label': i});
    bi.save(ch);
    eIds[ch.getKey()] = en.getKey();
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKey(acctId, true);
    attachError(iter, assert);
    iter.on('object', function(obj) {
      assert.equal(eIds[obj.getKey()], obj.entity_id);
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_hierarchical_with_children_obj_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Check),
      acctId = 'aFoo',
      eId = 'en171',
      bi = new BatchInsert(ctx, acctId),
      ch, bc, results = [],
      objs = 16, i,
      testCount = 0;

  bi.begin();

  for (i = 0; i < objs; i++) {
    ch = new Check({'account_id': acctId, 'entity_id': eId, 'label': i});
    bi.save(ch);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': eId, 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': eId, 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKey(acctId, false);
    attachError(iter, assert);
    iter.on('object', function(obj) {
      assert.equal(obj.bound_checks.length, 2);
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_hierarchical_with_children_parent_obj_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Check),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      ch, bc, results = [],
      objs = 16, i, en,
      diffEntities = 4,
      testCount = 0;

  bi.begin();

  en = new Entity({});
  bi.save(en);
  for (i = 0; i < objs; i++) {
    if (i % parseInt((objs / diffEntities), 10) === 0) {
      en = new Entity({});
      bi.save(en);
    }
    ch = new Check({'account_id': acctId, 'entity_id': en.getKey(), 'label': i});

    bi.save(ch);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKeyWithParent(acctId, Entity);
    attachError(iter, assert);
    iter.on('object', function(obj) {
      assert.equal(obj.bound_checks.length, 2);
      assert.equal(obj.parent.key, obj.parentKey());
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};


exports['test_hierarchical_with_children_and_startsWith'] = function(test, assert) {
  var ctx = context.create(log),
      iter = new BaseObjectIterator(ctx, Check),
      acctId = 'aFoo',
      bi = new BatchInsert(ctx, acctId),
      ch, bc, results = [],
      objs = 16, i, en,
      eId,
      testCount = 0;

  bi.begin();

  en = new Entity({});
  eId = en.getKey();
  bi.save(en);
  for (i = 0; i < objs; i++) {
    // Half go to a different entity
    if (objs / i === 2) {
      en = new Entity({});
      bi.save(en);
    }
    ch = new Check({'account_id': acctId, 'entity_id': en.getKey(), 'label': i});
    bi.save(ch);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i, 'check_id': ch.getKey()});
    bi.save(bc);
  }

  bi.commit(function(err) {
    assert.deepEqual(err, null);

    iter.getSliceByKey(acctId, false, eId);
    attachError(iter, assert);
    iter.on('object', function(obj) {
      assert.equal(obj.entity_id, eId);
      assert.equal(obj.bound_checks.length, 2);
      testCount++;
    });
    iter.on('end', function() {
      assert.equal(iter.total, objs / 2);
      assert.equal(iter.total, testCount);
      removeKey(ctx, acctId, function(err) {
        assert.ifError(err);
        test.finish();
      });
    });
  });
};

exports['test_index'] = function(test, assert) {
  var ctx = context.create(log),
      acctId = 'aFoo',
      eId = 'en171',
      bi = new BatchInsert(ctx, acctId),
      ch, bc, results = [],
      objs = 3,
      colId = 'colA',
      testCount = 0, i, en;

  async.waterfall([
    function createEntities(callback) {
      bi.begin();

      var en = new Entity({});
      bi.save(en);
      for (i = 0; i < objs; i++) {
        ch = new Check({'account_id': acctId, 'entity_id': en.getKey(), 'label': i});
        bi.save(ch);
        bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i,
          'check_id': ch.getKey(), 'collector_id': colId});
        bi.save(bc);
      }

      bi.commit(function(err) {
        assert.ifError(err);
        callback();
      });
    },


    function getIndex(callback) {
      var iter = new IndexIterator(ctx, BoundCheck, null),
          testCount = 0;

      iter.getIndex('collector_idx', colId);

      attachError(iter, assert);
      iter.on('object', function(obj) {
        testCount++;
      });

      iter.on('end', function() {
        assert.equal(iter.total, testCount);
        assert.equal(iter.total, 3);
        callback();
      });
    },

    function getPaginatedIndexFirst(callback) {
      var iter = new PaginatedIndexIterator(ctx, BoundCheck, null, {limit: 2}),
          testCount = 0;

      iter.getIndex('collector_idx', colId);

      attachError(iter, assert);
      iter.on('object', function(obj) {
        testCount++;
      });

      iter.on('end', function(meta) {
        assert.equal(testCount, 2);
        assert.ok(meta.nextKey);
        callback(null, meta.nextKey);
      });
    },

    function getPaginatedIndexNextKey(nextKey, callback) {
      var iter = new PaginatedIndexIterator(ctx, BoundCheck, null, {limit: 2}),
          testCount = 0;

      iter.getIndex('collector_idx', colId, {starting: nextKey});

      attachError(iter, assert);
      iter.on('object', function(obj) {
        testCount++;
      });

      iter.on('end', function(meta) {
        assert.equal(testCount, 1);
        assert.equal(meta.nextKey, null);
        callback();
      });
    },

    function remove(callback) {
      async.parallel([
        function(callback) {
          removeKey(ctx, acctId, function(err) {
            assert.ifError(err);
            callback();
          });
        },
        function(callback) {
          removeKey(ctx, colId, function(err) {
            assert.ifError(err);
            callback();
          });
        }
      ], callback);
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_get_keys_from_index'] = function(test, assert) {
  var ctx = context.create(log),
      acctId = 'aHorse',
      ii = new IndexIterator(ctx, Entity, acctId),
      ri = new RowPaginatedIndexIterator(ctx, 'agent_to_entity_idx', {dataPrefix: acctId + ':'}),
      entityKeys = [],
      keys = [];

  async.series([
    function addEntities(callback) {
      var bi = new BatchInsert(ctx, acctId),
          en, i;

      bi.begin();
      for (i = 1; i <= 4; i++) {
        en = new Entity({'account_id': acctId, 'label': 'apples' + i, 'agent_id': i});
        entityKeys.push(en.getKey());
        bi.save(en);
      }
      bi.commit(callback);
    },

    function getKeys(callback) {
      ii.getKeysFromIndex('agent_to_entity_idx', [1, 2, 3, 4]);

      ii.on('key', function(key) {
        keys.push(key);
      });

      ii.on('end', callback);
      ii.on('error', callback);
    },
    
    function getKeyCol(callback) {
      var count = 0;

      async.whilst(
          function () { return count < 4; },
          function (callback) {
            ri.getOneIndexRow('' + (count + 1) ,function(err, row) {
              assert.ifError(err);
              assert.deepEqual(row.name, acctId + ':' + entityKeys[count]);
              ++count;
              callback();
            });
          },callback);
    },
    function getSlice(callback) {
      ri.getIndexSlice({}, function(err, slice) {
        assert.ifError(err);
        var i;
        assert.deepEqual(slice.length,4);
        for(i = 0; i < 4; i++) {
          assert.deepEqual(slice[i].value, acctId + ':' + entityKeys[i]);
        }
        callback(err);
      });
    },
    function getSliceStart(callback) {
      ri.getIndexSlice({starting:'2'}, function(err, slice) {
        assert.ifError(err);
        assert.deepEqual(slice.length,3);
        var i;
        for(i = 0; i < 2; i++) {
          assert.deepEqual(slice[i].value, acctId + ':' + entityKeys[i+1]);
        }
        callback(err);
      });
    },
    function getSliceLimit(callback) {
      ri.getIndexSlice({limit: 2}, function(err, slice) {
        assert.ifError(err);
        assert.deepEqual(slice.length,2);
        var i;
        for(i = 0; i < 2; i++) {
          assert.deepEqual(slice[i].value, acctId + ':' + entityKeys[i]);
        }
        callback(err);
      });
    },
    function getSliceLimitStart(callback) {
      ri.getIndexSlice({starting:'2', limit: 2}, function(err, slice) {
        assert.ifError(err);
        assert.deepEqual(slice.length,2);
        var i;
        for(i = 0; i < 2; i++) {
          assert.deepEqual(slice[i].value, acctId + ':' + entityKeys[i+1]);
        }
        callback(err);
      });
    }
  ],

  function(err) {
    var i;
    assert.ifError(err);
    assert.equal(keys.length, 4);
    for (i = 0; i < 4; i++) {
      assert.notEqual(entityKeys.indexOf(keys[i]), -1);
    }
    test.finish();
  });
};

exports['test_get_keys_from_index_with_multipart_name'] = function(test, assert) {
  var ctx = context.create(log),
      rowKey = 'aFamily',
      ii = new IndexIterator(ctx, Person, rowKey),
      personKeys = [],
      keys = [];

  async.series([
    function addPeople(callback) {
      var bi = new BatchInsert(ctx, rowKey),
          per, i;

      bi.begin();
      for (i = 1; i <= 4; i++) {
        per = new Person({'name': 'Tomaz #'+i, 'ssn': i});
        personKeys.push(per.getKey());
        bi.save(per);
      }
      bi.commit(callback);
    },

    function getKeys(callback) {
      ii.getKeysFromIndex('ssn_to_person_idx', [1, 2, 3, 4]);

      ii.on('key', function(key) {
        keys.push(key);
      });

      ii.on('end', callback);
      ii.on('error', callback);
    }
    ], function(err) {
      var i;
      assert.ifError(err);
      assert.equal(keys.length, 4);
      for (i = 0; i < 4; i++) {
        assert.notEqual(personKeys.indexOf(keys[i]), -1);
      }
      test.finish();
    }
  );
};

exports['test_object_iterator_removed_objects_are_filtered_properly'] = function(test, assert) {
  var ctx = context.create(log),
      oi = new ObjectIterator(ctx, Entity, { count: 10 }),
      acctId = 'aBar',
      bi1 = new BatchInsert(ctx, acctId),
      bi2 = new BatchInsert(ctx, acctId),
      en,
      eIds = [], entities = [],
      objs = 21,
      removeObjs = 10,
      i, params,
      testCount = 0;

  bi1.begin();

  for (i = 0; i < objs; i++) {
    en = new Entity({'account_id': acctId, 'label': i});
    eIds.push(en.getKey());
    entities.push(en);
    bi1.save(en);
  }

  async.series([
    // Commit
    bi1.commit.bind(bi1),

    // Remove 10 entities and commit
    function removeEntities(callback) {
      var i, en;

      bi2.begin();

      for (i = 0; i < removeObjs; i++) {
        en = entities[i];
        bi2.removeObject(en);
      }

      bi2.commit(callback);
    },

    // Get entities
    function commit(callback) {
      oi.getColumnListByKey(acctId, eIds);

      oi.on('object', function(obj) {
        testCount++;
      });

      attachError(oi, assert);
      oi.on('end', function() {
        // 'object' event should only be emitted for non deleted objects
        assert.equal(oi.total, 21);
        assert.equal(testCount, 11);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};


exports['test_index_remove_manual'] = function(test, assert) {
  var ctx = context.create(log),
      acctId = 'aFoo',
      eId = 'en171',
      bi = new BatchInsert(ctx, acctId),
      ch, bc, results = [],
      objs = 3,
      colId = 'colA',
      testCount = 0, i, en;

  bi.begin();

  en = new Entity({});
  bi.save(en);
  for (i = 0; i < objs; i++) {
    ch = new Check({'account_id': acctId, 'entity_id': en.getKey(), 'label': i});
    bi.save(ch);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i,
      'check_id': ch.getKey(), 'collector_id': colId});
    bi.save(bc);
    bc = new BoundCheck({'account_id': acctId, 'entity_id': en.getKey(), 'label': i,
      'check_id': ch.getKey(), 'collector_id': colId});
    bi.save(bc);
  }

  async.series([
    function firstCommit(callback) {
      bi.commit(function(err) {
        assert.deepEqual(err, null);
        callback();
      });
    },
    function getCall(callback) {
      var iter = new IndexIterator(ctx, BoundCheck, null);
      iter.getIndex('collector_idx', colId);

      attachError(iter, assert);
      iter.on('object', function(obj) {
        testCount++;
      });

      iter.on('end', function() {
        assert.equal(iter.total, testCount);
        assert.equal(iter.total, (3 * 2));
        callback();
      });
    },
    removeKeyDef.bind(null, ctx, acctId, BoundCheck),
    removeKeyDef.bind(null, ctx, colId, BoundCheck.meta.indexes['collector_idx']),
    function getCallEmpty(callback) {
      testCount = 0;
      var iter = new IndexIterator(ctx, BoundCheck, null);

      iter.getIndex('collector_idx', colId);

      attachError(iter, assert);
      iter.on('object', function(obj) {
        testCount++;
      });

      iter.on('end', function() {
        assert.equal(iter.total, testCount);
        assert.equal(iter.total, 0);
        callback();
      });
    }
  ],
  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_db_errors'] = function(test, assert) {
  var ctx = context.create(log);

  async.waterfall([
    // valid host:port, invalid keyspace
    function testNotFoundException(callback) {
      var pool = cutils.getPoolUnsafe(['127.0.0.1:9160'], 'INVALID_KEYSPACE_VNEISKW');
      pool.execute(ctx, 'select * from objects', [], function(err, res) {
        assert.ok(err);
        assert.strictEqual(err.details, 'NotFoundException');
        assert.ok(!(err instanceof errors.DbDownError));
        assert.ok(err instanceof errors.CassandraError);
        pool.shutdown(callback);
      });
    },

    // invalid host:port
    function testAllBad(callback) {
      var pool = cutils.getPoolUnsafe(['127.0.0.1:19179'], 'objects');
      pool.execute(ctx, 'select * from objects', [], function(err, res) {
        assert.ok(err);
        assert.ok(err.message.indexOf('All connections are unhealthy.') !== -1);
        assert.ok(err instanceof errors.DbDownError);
        pool.shutdown(callback);
      });
    }
  ], function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_create_index_empty_index_value'] = function(test, assert) {
  var ctx = {'log': log}, pool = cutils.getConnPool(), en;

  async.series([
    function testCreateAccountEmptyValue(callback) {
      var bi, ac;

      ac = new Account({'external_id': null});
      bi = new BatchInsert(ctx, ac.getKey());
      bi.begin();
      bi.save(ac);
      bi.commit(callback);
    },

    function verifyIndexHasNotBeenCreated(callback) {
      var query = 'SELECT * FROM ? USING CONSISTENCY ONE WHERE KEY = ?;',
          args = ['account_external_idx', 'null'];

      pool.execute(ctx, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res.rowCount(), 1);
        assert.equal(res[0].key, 'null');
        assert.equal(res[0].cols.length, 0);
        callback();
      });
    },

    function testCreateAccount(callback) {
      var bi, ac;

      ac = new Account({'external_id': 'barfooii'});
      bi = new BatchInsert(ctx, ac.getKey());
      bi.begin();
      bi.save(ac);
      bi.commit(callback);
    },

    function verifyIndexHasBeenCreated(callback) {
      var query = 'SELECT * FROM ? USING CONSISTENCY ONE WHERE KEY = ?;',
          args = ['account_external_idx', 'barfooii'];

      pool.execute(ctx, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res.rowCount(), 1);
        assert.equal(res[0].key, 'barfooii');
        assert.equal(res[0].cols.length, 1);
        callback();
      });
    },

    function createEntity(callback) {
      var bi;

      bi = new BatchInsert(ctx, 'acFoo');
      bi.begin();
      en = new Entity({'label': 'foo', 'agent_id': 'ponies'});
      bi.save(en);
      bi.commit(callback);
    },

    function verifyIndexRowKey(callback) {
      var query = 'SELECT * FROM ? USING CONSISTENCY ONE WHERE KEY = ?;',
          args = ['agent_to_entity_idx', 'acFoo:ponies'];

      pool.execute(ctx, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res.rowCount(), 1);
        assert.equal(res[0].key, 'acFoo:ponies');
        assert.equal(res[0].cols.length, 1);
        callback();
      });
    },

    function testIndexCleanupWorks(callback) {
      var bi = new BatchInsert(ctx, 'acFoo');
      bi.begin();
      bi.removeObject(en);
      bi.commit(callback);
    },

    function verifyIndexHasBeenRemoved(callback) {
      var query = 'SELECT * FROM ? USING CONSISTENCY ONE WHERE KEY = ?;',
          args = ['agent_to_entity_idx', 'acFoo:ponies'];

      pool.execute(ctx, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res.rowCount(), 1);
        assert.equal(res[0].cols.length, 0);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_get_object_for_index_non_prefixed_key'] = function(test, assert) {
  var acct = new Account({'external_id': 'ponies'}), ctx = {'account': acct};

  async.waterfall([
    function createAgentToken(callback) {
      var bi = new BatchInsert(ctx, acct.getKey()), at;

      at = new AgentToken({'label': test});
      at.generateAndAssignToken(ctx);
      bi.save(at);
      bi.commit(function(err) {
        callback(err, at);
      });
    },

    function getAgentTokenByIndex(at, callback) {
      var iter = new IndexIterator(ctx, AgentToken, null),
          count = 0;

      iter.getIndex('agent_token_idx', at.getKey());

      attachError(iter, assert);
      iter.on('object', function(obj) {
        count++;
      });

      iter.on('end', function() {
        assert.equal(iter.total, 1);
        assert.equal(iter.total, count);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_get_one_object'] = function(test, assert) {
  var acctKey = 'acFoo',
      ctx = context.create(log),
      en;

  async.series([

    function createEntity(callback) {
      var bi;

      bi = new BatchInsert(ctx, acctKey);
      bi.begin();
      en = new Entity({'label': 'foo'});
      bi.save(en);
      bi.commit(callback);
    },

    function getOne(callback) {
      var boi = new BaseObjectIterator(ctx, Entity);

      boi.getOneObject(acctKey, [], en.getKey(), function(err, obj) {
        assert.ifError(err);
        assert.equal(obj.getKey(), en.getKey());
        test.finish();
      });
    }]);
};


exports['test_get_one_non-existent_object'] = function(test, assert) {
  var acctKey = 'acFoo',
      ctx = context.create(log),
      boi = new BaseObjectIterator(ctx, Entity);

  boi.getOneObject(acctKey, [], 'enFAKEFAK', function(err, obj) {
    // Similar to ColumnIterator.getOneColumn(), getting a non-existent object should not raise an error
    assert.ifError(err);
    test.finish();
  });
};


exports['test_get_object_and_children'] = function(test, assert) {
  var acctId = 'acFoo',
      ctx = context.create(log),
      en,
      checkCount = 5;

  async.series([

    function insertEntity(callback) {
      var bi;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();
      en = new Entity({'label': 'foo'});
      bi.save(en);
      bi.commit(callback);
    },

    function insertChecks(callback) {
      var bi, i, ch;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();
      for (i = 0; i < checkCount; i++) {
        ch = new Check({'account_id': acctId, 'label': i, 'entity_id': en.getKey()});
        bi.save(ch);
      }
      bi.commit(callback);
    },

    function getObjectAndChildren(callback) {
      var boi = new BaseObjectIterator(ctx, Entity);

      boi.getObjectAndChildren(acctId, [], en.getKey());
      boi.on('object', function(obj) {
        var i;
        assert.equal(obj.getKey(), en.getKey());
        assert.equal(obj.checks.length, checkCount);
        for (i=0; i < checkCount; i++) {
          assert.equal(obj.checks[i]._type.meta.name, 'Check');
        }
      });
      boi.on('end', test.finish);
      boi.on('error', function(err) {
        assert.ifError(err);
        test.finish();
      });
    }]);
};


exports['test_get_object_and_children_but_no_deleted_children'] = function(test, assert) {
  var acctId = 'acFoo',
      ctx = context.create(log),
      en,
      checkCount = 5,
      checkToDelete;

  async.series([

    function insertEntity(callback) {
      var bi;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();
      en = new Entity({'label': 'foo'});
      bi.save(en);
      bi.commit(callback);
    },

    function insertChecks(callback) {
      var bi, i, ch;

      bi = new BatchInsert(ctx, acctId);
      bi.begin();
      for (i = 0; i < checkCount; i++) {
        ch = new Check({'account_id': acctId, 'label': i, 'entity_id': en.getKey()});
        bi.save(ch);
        if (i === 0) {
          checkToDelete = ch;
        }
      }
      bi.commit(callback);
    },

    function deleteACheck(callback) {
      var bi = new BatchInsert(ctx, acctId);
      bi.begin();
      bi.removeObject(checkToDelete);
      bi.commit(callback);
    },

    function getObjectAndChildren(callback) {
      var boi = new BaseObjectIterator(ctx, Entity);

      boi.getObjectAndChildren(acctId, [], en.getKey());
      boi.on('object', function(obj) {
        var i;
        assert.equal(obj.getKey(), en.getKey());
        assert.equal(obj.checks.length, checkCount - 1);
        for (i=0; i < checkCount - 1; i++) {
          assert.equal(obj.checks[i]._type.meta.name, 'Check');
          assert.notEqual(obj.checks[i].getKey(), checkToDelete.getKey());
        }
      });
      boi.on('end', test.finish);
      boi.on('error', function(err) {
        assert.ifError(err);
        callback();
      });
    }], test.finish);
};


exports['test_col_iterator_getLastColumn'] = function(test, assert) {
  var ctx = context.create(log), i, en,
      rowKey = 'abcdefgh',
      ci = new ColumnIterator(ctx, Entity.meta.columnFamily, {'dataPrefix': Entity.meta.dataPrefix}),
      bi = new BatchInsert(ctx, rowKey);

  for (i = 0; i < 10; i++) {
    en = new Entity({'account_id': 'abcd', 'label': i});
    bi.save(en);
  }

  async.series([
    function commit(callback) {
      bi.commit(callback);
    },

    function retrieveLastColumn(callback) {
      ci.getLastColumn(rowKey, function(err, col) {
        assert.ifError(err);
        assert.ok(col);
        assert.match(col.name, /_en/);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_obj_iterator_getLastObject'] = function(test, assert) {
  var ctx = context.create(log), i, en,
      rowKey = 'bcdefgh',
      oi = new BaseObjectIterator(ctx, Entity),
      bi = new BatchInsert(ctx, rowKey);

  for (i = 0; i < 10; i++) {
    en = new Entity({'account_id': 'abcd', 'label': i});
    bi.save(en);
  }

  async.series([
    function commit(callback) {
      bi.commit(callback);
    },

    function retrieveLastObject(callback) {
      oi.getLastObject(rowKey, function(err, obj) {
        assert.ifError(err);
        assert.ok(obj);
        assert.match(obj.getKey(), /en/);
        assert.ok(obj instanceof Entity);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_obj_iterator_getLastObject_no_columns'] = function(test, assert) {
  var ctx = context.create(log), i, en,
      rowKey = 'a1234',
      oi = new BaseObjectIterator(ctx, Entity);

  oi.getLastObject(rowKey, function(err, obj) {
    assert.ifError(err);
    assert.ok(!obj);
    test.finish();
  });
};

exports['test_ScopedOneToMany_index'] = function(test, assert) {
  var acKey = 'acWQEE';

  async.waterfall([
    function createService1(callback) {
      var bi, srv, params;

      params = {
        '_key': 'srvmessenger-0',
        'session_id': 'seAAAA',
        'tags': ['messenger', 'fb303', 'stats']
      };

      bi = new BatchInsert({}, acKey);
      srv = new Service(params);
      bi.save(srv);
      bi.commit(function(err) {
        callback(err);
      });
    },

    function createService2(callback) {
      var bi, srv, params;

      params = {
        '_key': 'srvapi-0',
        'session_id': 'seAAAA',
        'tags': ['api', 'fb303', 'stats']
      };

      bi = new BatchInsert({}, acKey);
      srv = new Service(params);
      bi.save(srv);
      bi.commit(function(err) {
        callback(err);
      });
    },

    function createService3(callback) {
      var bi, srv, params;

      params = {
        '_key': 'srvapi-1',
        'session_id': 'seAAAAA',
        'tags': ['api', 'fb303', 'stats']
      };

      bi = new BatchInsert({}, acKey);
      srv = new Service(params);
      bi.save(srv);
      bi.commit(function(err) {
        callback(err);
      });
    },

    function createService4(callback) {
      var bi, srv, params;

      params = {
        '_key': 'srvapi-2',
        'session_id': 'seBBBB',
        'tags': ['api', 'fb303', 'stats']
      };

      bi = new BatchInsert({}, acKey);
      srv = new Service(params);
      bi.save(srv);
      bi.commit(function(err) {
        callback(err);
      });
    },

    function getForExistingSession(callback) {
      var iter, objs = [];

      iter = new PaginatedIndexIterator({}, Service, acKey, {'limit': 100});
      iter.on('error', callback);

      iter.on('object', function(obj) {
        objs.push(obj);
      });

      iter.on('end', function() {
        assert.equal(objs.length, 2);
        assert.equal(objs[0].getKey(), 'srvapi-0');
        assert.equal(objs[1].getKey(), 'srvmessenger-0');
        callback();
      });

      iter.getIndex('session_idx', 'seAAAA', {});
    },

    function getForNonExistingSession(callback) {
      var iter, objs = [];

      iter = new PaginatedIndexIterator({}, Service, acKey, {'limit': 100});
      iter.on('error', callback);

      iter.on('object', function(obj) {
        objs.push(obj);
      });

      iter.on('end', function() {
        assert.equal(objs.length, 0);
        callback();
      });

      iter.getIndex('session_idx', 'seDoesntExist', {});
    },

    function getForExistingTag1(callback) {
      var iter, objs = [];

      iter = new PaginatedIndexIterator({}, Service, acKey, {'limit': 100});
      iter.on('error', callback);

      iter.on('object', function(obj) {
        objs.push(obj);
      });

      iter.on('end', function() {
        assert.equal(objs.length, 1);
        assert.equal(objs[0].getKey(), 'srvmessenger-0');
        callback();
      });

      iter.getIndex('tags_idx', 'messenger', {});
    },

    function getForExistingTag2(callback) {
      var iter, objs = [];

      iter = new PaginatedIndexIterator({}, Service, acKey, {'limit': 100});
      iter.on('error', callback);

      iter.on('object', function(obj) {
        objs.push(obj);
      });

      iter.on('end', function() {
        assert.equal(objs.length, 4);
        callback();
      });

      iter.getIndex('tags_idx', 'fb303', {});
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};


exports['test_row_key_iterator'] = function(test, assert) {
  var ctx = context.create(log),
      rki = new RowKeyIterator(ctx, Entity.meta.columnFamily),
      keys = [];

  rki.getKeys();

  rki.on('error', function(err) {
    assert.ifError(err);
    assert.fail();
  });

  rki.on('key', function(key) {
    keys.push(key);
  });

  rki.on('end', function() {
    assert.equal(keys.filter(function(key) {
      return ['aBar', 'aBar1', 'fooo'].indexOf(key) !== -1;
    }).length, 3);
    test.finish();
  });
};
