/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var async = require('async');
var log = require('logmagic').local('tests.test-orm-batch-insert');

var BatchInsert = require('../lib/orm/batch_insert').BatchInsert;
var getConnPool = require('../lib/orm/utils').getConnPool;
var compoundColumn = require('../lib/orm/utils').compoundColumn;
var SPECIAL_FIELDS = require('../lib/orm/constants').SPECIAL_FIELDS;
var Entity = require('../examples/models/entity').Entity;
var common = require('./common');

exports['setUp'] = common.setUp;
exports['tearDown'] = common.tearDown;

exports['test_create_batch_insert_save'] = function(test, assert) {
  var key = 'aBueno',
      bi = new BatchInsert({log: log}, key),
      check = new Entity({});

  // Mainly testing the internals
  bi.begin();
  bi._save(check._type, check.toDb());
  bi._prepCommit(function(err, result) {
    // Begin, Statement, Commit
    assert.equal(1, bi._query.length);
    // CF, CN (composite key), CV (json payload), KEY
    assert.equal(4, bi._args.length);
    assert.ifError(err);
    test.finish();
  });
};

exports['test_missing_key_argument'] = function(test, assert) {
  var ctx = {'log': log}, args = [null, undefined, ''], i,
      exceptionCount = 0, bi;

  for (i = 0; i < args.length; i++) {
    try {
      bi = new BatchInsert(ctx, args[i]);
    }
    catch (err) {
      exceptionCount++;
    }
  }

  assert.equal(exceptionCount, 3);
  test.finish();
};

exports['test_commit_no_queries'] = function(test, assert) {
  var bi = new BatchInsert({log: log}, 'fooo');
  bi.begin();

  bi.commit(function(err, x) {
    test.finish();
  });
};

exports['test_soft_delete'] = function(test, assert) {
  async.waterfall([
    function saveEntity(callback) {
      var bi, en;

      bi = new BatchInsert({log: log}, 'fooo');
      bi.begin();
      en = new Entity({'account_id': 'abc', 'label': 'en1'});
      bi.save(en);
      bi.commit(function(err) {
        callback(err, en);
      });
    },

    function softDelete(en, callback) {
      var bi = new BatchInsert({log: log}, 'fooo');

      bi.begin();
      bi.removeObject(en, 'soft');

      bi.commit(function(err) {
        callback(err, en);
      });
    },

    function verifySoftDelete(en, callback) {
      var query, args, enKey;

      query = 'SELECT ? FROM objects WHERE key = fooo';
      enKey = '_' + en.getKey();
      args = [enKey];
      getConnPool().execute({}, query, args, function(err, res) {
        var parsed;

        assert.ifError(err);
        assert.ok(res[0].colHash.hasOwnProperty(enKey));
        parsed = JSON.parse(res[0].colHash[enKey]);
        assert.equal(parsed[SPECIAL_FIELDS.removed], true);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_hard_delete'] = function(test, assert) {
  var acKey = 'fooo', agentKey = 'someAgent';

  async.waterfall([
    function saveEntity(callback) {
      var bi, en;

      bi = new BatchInsert({log: log}, acKey);
      bi.begin();
      en = new Entity({'account_id': 'abc', 'label': 'en2', 'agent_id': agentKey});
      bi.save(en);
      bi.commit(function(err) {
        callback(err, en);
      });
    },

    function verifyIndexHasBeenCreated(en, callback) {
      var query, args;

      query = 'SELECT * FROM  agent_to_entity_idx WHERE key = ?';
      args = [compoundColumn([acKey, agentKey])];
      getConnPool().execute({}, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res[0].cols.length, 1);
        callback(null, en);
      });
    },

    function hardDelete(en, callback) {
      var bi = new BatchInsert({log: log}, 'fooo');

      bi.begin();
      bi.removeObject(en, 'hard');

      bi.commit(function(err) {
        callback(err, en);
      });
    },

    function verifyHardDelete(en, callback) {
      var query, args, enKey;

      query = 'SELECT ? FROM objects WHERE key = fooo';
      enKey = '_' + en.getKey();
      args = [enKey];
      getConnPool().execute({}, query, args, function(err, res) {
        var parsed;

        assert.equal(res[0].cols.length, 0);
        assert.deepEqual(res[0].colHash, {});
        assert.ifError(err);
        callback(null, en);
      });
    },

    function verifyIndexHasBeenRemoved(en, callback) {
      var query, args, enKey;

      query = 'SELECT * FROM  agent_to_entity_idx WHERE key = ?';
      enKey = '_' + en.getKey();
      args = [compoundColumn([acKey, agentKey])];
      getConnPool().execute({}, query, args, function(err, res) {
        assert.ifError(err);
        assert.equal(res[0].cols.length, 0);
        callback();
      });
    }
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};
