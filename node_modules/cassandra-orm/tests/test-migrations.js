/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var path = require('path');
var fs = require('fs');

var log = require('logmagic').local('tests');
var async = require('async');
var fsUtil = require('rackspace-shared-utils/lib/fs');

var TestModel1 = require('./migrations/testmodel1').TestModel1;
var TestModel2 = require('./migrations/testmodel2').TestModel2;
var FIELDS1 = require('./migrations/testmodel1').FIELDS;
var FIELDS2 = require('./migrations/testmodel2').FIELDS;
var Account = require('../examples/models/account').Account;
var BatchInsert = require('../lib/orm/batch_insert').BatchInsert;
var migrationConstants = require('../lib/migrations/constants');
var migrationsRegistry = require('../lib/migrations/registry');
var migrations = require('../lib/migrations/migrations');
var PaginatedObjectIterator = require('../lib/orm/iterator').PaginatedObjectIterator;
var init = require('../lib/init');
var run = require('../lib/migrations/run');
var common = require('./common');

function removeGeneratesFiles(callback) {
  var directory = path.join(__dirname, 'migrations/testmodel2');

  fsUtil.getMatchingFiles(directory, /\.js$/, null, function(err, files) {
    async.forEach(files, fs.unlink, callback);
  });
}

exports['setUp'] = function(test, assert) {
  common.init(null, function() {
    removeGeneratesFiles(test.finish);
  });
};

exports['tearDown'] = function(test, assert) {
  common.shutdown(function() {
    removeGeneratesFiles(test.finish);
  });
};

exports['test_getModelsFieldsDiff'] = function(test, assert) {
  var fields1, fields2, result;

  fields1 = {
    'a': null,
    'b': null,
    'c': {default_value: 'bar'},
    'd': {default_value: 'foo'}
  };
  fields2 = {
    'b': null,
    'c': {default_value: 'ponies'},
    'd': {default_value: 'foo'},
    'g': {default_value: 'bar'}
  };

  result = migrations.getModelsFieldsDiff(fields1, fields2);

  assert.equal(result.add.length, 1);
  assert.equal(result.remove.length, 1);
  assert.equal(result.change_options.length, 1);

  assert.equal(result.add[0].name, 'g');
  assert.equal(result.add[0].options, fields2.g);

  assert.equal(result.remove[0].name, 'a');
  assert.equal(result.remove[0].options, fields2.a);

  assert.equal(result.change_options[0].name, 'c');
  assert.equal(result.change_options[0].options, fields2.c);

  test.finish();
};

exports['test_migrations'] = function(test, assert) {
  var migrationNames = ['rename_name_to_label', 'change_date_to_unix_timestamp', 'change_url_default_value'],
      acct = new Account({ _key: 'acOne'}),
      ctx = {'log': log, 'account': acct},
      initialParams = {
        'name': 'test name #1',
        'description': 'your mom foo',
        'url': null,
        'date': new Date().toString()
      },
      version1Params = {
        'label': initialParams.name,
        'description': initialParams.description,
        'url': 'http://www.default.com',
        'date': initialParams.date
      },
      version2Params = {
        'label': initialParams.name,
        'description': initialParams.description,
        'url': 'http://www.default.com',
        'date': (Date.parse(initialParams.date) / 1000)
      },
      version3Params = {
        'label': initialParams.name,
        'description': initialParams.description,
        'url':'http://www.default.com',
        'date': version2Params.date
      },
      testParams = {
        'name': initialParams.name,
        'description': initialParams.description,
        'url': 'http://www.default.com',
        'date': initialParams.date
      },
      tm, tm2;

  function getTestModel1(ctx, key, callback) {
    var rowKey, objKey, iter, result = [];

    rowKey = ctx.account.getKey();
    objKey = key;

    iter = new PaginatedObjectIterator(ctx, TestModel1, {});
    iter.getSliceByKey(rowKey, false, objKey, objKey);

    iter.on('error', callback);

    iter.on('object', function iterOnObject(obj) {
      result.push(obj);
    });

    iter.on('end', function iterOnEnd(data) {
      callback(null, result[0]);
    });
  }

  async.waterfall([
    // Clean the registry
    function cleanRegistry(callback) {
      migrationsRegistry.registry = {};
      callback();
    },

    function initializeAndAssignMigrationsAttributeToObject(callback) {
      var options = {'migrationsPath': path.join(__dirname, 'migrations')};
      common.init(options, callback);
    },

    // Add item to DB at the first version (operational version = 0)
    function addItemToDbVersion0(callback) {
      TestModel1.operationalVersion = 0;
      var bi = new BatchInsert(ctx, ctx.account.getKey());
      bi.begin();
      tm = new TestModel1(initialParams);
      bi.save(tm);
      bi.commit(callback);
    },

    function getObject(callback) {
      getTestModel1(ctx, tm.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(testParams, _tm);
      callback();
    },

    /* 1. Try full migrations without writing */

    // Migration path: |0| -> 1
    function getObject(callback) {
      TestModel1.operationalVersion = 1;
      getTestModel1(ctx, tm.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(version1Params, _tm);
      callback();
    },

    // Migration path: |0| -> 1 -> 2
    function getObject(callback) {
      TestModel1.operationalVersion = 2;
      getTestModel1(ctx, tm.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(version2Params, _tm);
      callback();
    },

    // Migration path: |0| -> 1 -> 2 -> 3
    function getObject(callback) {
      TestModel1.operationalVersion = 3;
      getTestModel1(ctx, tm.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(version2Params, _tm);
      callback();
    },

    // Add item to DB at the third version (operational version = 3)
    function addItemToDbVersion3(callback) {
      TestModel1.operationalVersion = 3;
      var bi = new BatchInsert(ctx, ctx.account.getKey());
      bi.begin();
      tm2 = new TestModel1(version3Params);
      bi.save(tm2);
      bi.commit(callback);
    },

    // Verify that the object has been saved at version 3
    function getObject(callback) {
      getTestModel1(ctx, tm2.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(version3Params, _tm);
      callback(null, _tm);
    },

    // Set operationalVersion to 1 and re-save the object. Backward migration should
    // be applied before saving the object to the database.
    // Migration path: 3 -> 2 -> |1|
    function testBackwardMigration(_tm, callback) {
      TestModel1.operationalVersion = 1;
      var bi = new BatchInsert(ctx, ctx.account.getKey());
      bi.begin();
      bi.save(_tm);
      bi.commit(callback);
    },

    // Verify that the object has been saved at version 2
    function getObject(callback) {
      getTestModel1(ctx, tm2.getKey(), callback);
    },

    function verifyObjectFields(_tm, callback) {
      assert.looseCompare(version1Params, _tm);
      callback();
    },

    removeGeneratesFiles
  ],

  function(err) {
    assert.ifError(err);
    test.finish();
  });
};

exports['test_migration_files_generation'] = function(test, assert) {
  var migrationNames = ['a', 'b'], options = {'migrationsPath': path.join(__dirname, 'migrations')};

  async.waterfall([
    function initializeAndAssignMigrationsAttributeToObject(callback) {
      //var options = {'migrationsPath': path.join(__dirname, 'migrations')};

      migrationsRegistry.registry = {};
      common.init(options, callback);
    },

    // Generate initial migration file
    function generateInitialMigrationFile(callback) {
      TestModel2.fields = FIELDS2[0];
      run.initialize(TestModel2.meta.name, callback);
    },

    function verifyMigationFile(callback) {
      var fields = require(path.join(__dirname, 'migrations/testmodel2/0000_initial.js')).FIELDS;
      assert.deepEqual(fields, FIELDS2[0]);
      callback();
    },

    // Generate migration files first.
    function generateMigrationFiles(callback) {
      var i = 0;

      async.forEachSeries(migrationNames, function(name, callback) {
        TestModel2.fields = FIELDS2[++i];
        run.generate(TestModel2.meta.name, name, null, function() {
          migrationsRegistry.registry = {};
          common.init(options, callback);
        });
      }, callback);
    },

    function verifyMigationFiles(callback) {
      var fields;

      fields = require(path.join(__dirname, 'migrations/testmodel2/0001_a.js')).FIELDS;
      assert.deepEqual(fields, FIELDS2[1]);
      fields = require(path.join(__dirname, 'migrations/testmodel2/0002_b.js')).FIELDS;
      assert.deepEqual(fields, FIELDS2[2]);

      callback();
    }
  ],

  function(err) {
    test.finish();
  });
};
